---
title: Snowflake Algorithm
description: Comprehensive guide to the Snowflake algorithm implementation in C++, including class methods, exception handling, and example usage for generating unique IDs.
---

## Overview

The Snowflake algorithm generates IDs that are:

- **Time-ordered**: IDs increase with time
- **Distributed**: Can work across multiple machines and datacenters
- **Unique**: Guarantees no ID collisions
- **Compact**: 64-bit integers that are efficient to store and process

## ID Structure

Each ID is a 64-bit integer composed of:

```
+-------------+-------------+-------------+-------------+
| Timestamp   | Datacenter  | Worker      | Sequence    |
| (41 bits)   | ID (5 bits) | ID (5 bits) | (12 bits)   |
+-------------+-------------+-------------+-------------+
```

## Key Features

- **Thread-safe operation** with configurable locking mechanisms
- **Customizable epoch** to minimize timestamp size
- **Support for multiple workers and datacenters**
- **Batch ID generation** for improved performance
- **Comprehensive error handling** with specialized exceptions
- **Advanced validation and parsing** capabilities
- **State serialization and deserialization**
- **Statistics collection** for monitoring

## Exception Classes

The implementation provides several specialized exception types:

### SnowflakeException

Base exception class for all Snowflake-related errors.

```cpp
throw SnowflakeException("Custom error message");
```

### InvalidWorkerIdException

Thrown when a worker ID exceeds the maximum allowed value.

```cpp
// This exception is thrown internally when:
if (worker_id > MAX_WORKER_ID) {
    throw InvalidWorkerIdException(worker_id, MAX_WORKER_ID);
}
```

### InvalidDatacenterIdException

Thrown when a datacenter ID exceeds the maximum allowed value.

```cpp
// This exception is thrown internally when:
if (datacenter_id > MAX_DATACENTER_ID) {
    throw InvalidDatacenterIdException(datacenter_id, MAX_DATACENTER_ID);
}
```

### InvalidTimestampException

Thrown when there's an issue with timestamp generation, typically due to clock synchronization problems.

```cpp
// This exception is thrown internally when:
if (timestamp < last_timestamp_) {
    throw InvalidTimestampException(timestamp);
}
```

## The Snowflake Class

### Template Parameters

- `Twepoch`: The custom epoch (in milliseconds) used as the starting point for timestamp generation
- `Lock`: The lock type to use for thread safety (defaults to `SnowflakeNonLock`)

### Constants

- `TWEPOCH`: The custom epoch time
- `WORKER_ID_BITS`: Number of bits for worker ID (5)
- `DATACENTER_ID_BITS`: Number of bits for datacenter ID (5)
- `MAX_WORKER_ID`: Maximum worker ID (31)
- `MAX_DATACENTER_ID`: Maximum datacenter ID (31)
- `SEQUENCE_BITS`: Number of bits for sequence (12)
- `SEQUENCE_MASK`: Mask for extracting sequence (4095)

### Constructor

```cpp
explicit Snowflake(uint64_t worker_id = 0, uint64_t datacenter_id = 0);
```

Creates a new Snowflake generator with the specified worker and datacenter IDs.

**Parameters:**

- `worker_id`: The ID of the worker generating the IDs (0-31)
- `datacenter_id`: The ID of the datacenter where the worker is located (0-31)

**Exceptions:**

- `InvalidWorkerIdException`: If the worker ID exceeds the maximum allowed value
- `InvalidDatacenterIdException`: If the datacenter ID exceeds the maximum allowed value

### Methods

#### init

```cpp
void init(uint64_t worker_id, uint64_t datacenter_id);
```

Initializes the Snowflake generator with new worker and datacenter IDs.

**Parameters:**

- `worker_id`: The new worker ID (0-31)
- `datacenter_id`: The new datacenter ID (0-31)

**Exceptions:**

- `InvalidWorkerIdException`: If the worker ID exceeds the maximum allowed value
- `InvalidDatacenterIdException`: If the datacenter ID exceeds the maximum allowed value

#### nextid

```cpp
template <size_t N = 1>
[[nodiscard]] auto nextid() -> std::array<uint64_t, N>;
```

Generates a batch of unique IDs.

**Template Parameters:**

- `N`: The number of IDs to generate (default: 1)

**Returns:**

- An array of N unique IDs

**Exceptions:**

- `InvalidTimestampException`: If the system clock is adjusted backwards

#### validateId

```cpp
[[nodiscard]] bool validateId(uint64_t id) const;
```

Validates if an ID was generated by this Snowflake instance.

**Parameters:**

- `id`: The ID to validate

**Returns:**

- `true` if the ID was generated by this instance, `false` otherwise

#### extractTimestamp

```cpp
[[nodiscard]] uint64_t extractTimestamp(uint64_t id) const;
```

Extracts the timestamp from a Snowflake ID.

**Parameters:**

- `id`: The Snowflake ID

**Returns:**

- The timestamp (in milliseconds since the epoch) extracted from the ID

#### parseId

```cpp
void parseId(uint64_t encrypted_id, uint64_t &timestamp,
             uint64_t &datacenter_id, uint64_t &worker_id,
             uint64_t &sequence) const;
```

Parses a Snowflake ID into its constituent parts.

**Parameters:**

- `encrypted_id`: The Snowflake ID to parse
- `timestamp`: Reference to store the extracted timestamp
- `datacenter_id`: Reference to store the extracted datacenter ID
- `worker_id`: Reference to store the extracted worker ID
- `sequence`: Reference to store the extracted sequence number

#### reset

```cpp
void reset();
```

Resets the Snowflake generator to its initial state.

#### getWorkerId

```cpp
[[nodiscard]] auto getWorkerId() const -> uint64_t;
```

Retrieves the current worker ID.

**Returns:**

- The current worker ID

#### getDatacenterId

```cpp
[[nodiscard]] auto getDatacenterId() const -> uint64_t;
```

Retrieves the current datacenter ID.

**Returns:**

- The current datacenter ID

#### getStatistics

```cpp
[[nodiscard]] Statistics getStatistics() const;
```

Retrieves statistics about ID generation.

**Returns:**

- A `Statistics` object containing:
  - `total_ids_generated`: Total number of IDs generated
  - `sequence_rollovers`: Number of sequence rollovers
  - `timestamp_wait_count`: Number of timestamp waits

#### serialize

```cpp
[[nodiscard]] std::string serialize() const;
```

Serializes the current state of the Snowflake generator to a string.

**Returns:**

- A string representing the serialized state

#### deserialize

```cpp
void deserialize(const std::string &state);
```

Deserializes the state of the Snowflake generator from a string.

**Parameters:**

- `state`: A string representing the serialized state

**Exceptions:**

- `SnowflakeException`: If the provided state string is invalid

## Complete Example

Here's a comprehensive example demonstrating the use of the Snowflake algorithm:

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include "atom/algorithm/snowflake.hpp"

// Using January 1, 2020 as our epoch
constexpr uint64_t CUSTOM_EPOCH = 1577836800000;

int main() {
    try {
        // Create a thread-safe Snowflake generator for datacenter 1, worker 2
        atom::algorithm::Snowflake<CUSTOM_EPOCH, std::mutex> snowflake(2, 1);
        
        std::cout << "Worker ID: " << snowflake.getWorkerId() << std::endl;
        std::cout << "Datacenter ID: " << snowflake.getDatacenterId() << std::endl;
        
        // Generate a single ID
        auto id = snowflake.nextid<1>()[0];
        std::cout << "Generated ID: " << id << std::endl;
        
        // Parse the ID to extract its components
        uint64_t timestamp, datacenter_id, worker_id, sequence;
        snowflake.parseId(id, timestamp, datacenter_id, worker_id, sequence);
        
        std::cout << "Parsed ID components:" << std::endl;
        std::cout << "  Timestamp: " << timestamp << std::endl;
        std::cout << "  Datacenter ID: " << datacenter_id << std::endl;
        std::cout << "  Worker ID: " << worker_id << std::endl;
        std::cout << "  Sequence: " << sequence << std::endl;
        
        // Validate the ID
        bool is_valid = snowflake.validateId(id);
        std::cout << "ID validation result: " << (is_valid ? "Valid" : "Invalid") << std::endl;
        
        // Generate a batch of 5 IDs
        auto batch = snowflake.nextid<5>();
        std::cout << "Generated batch of 5 IDs:" << std::endl;
        for (size_t i = 0; i < batch.size(); ++i) {
            std::cout << "  ID " << (i+1) << ": " << batch[i] << std::endl;
        }
        
        // Get statistics
        auto stats = snowflake.getStatistics();
        std::cout << "Statistics:" << std::endl;
        std::cout << "  Total IDs generated: " << stats.total_ids_generated << std::endl;
        std::cout << "  Sequence rollovers: " << stats.sequence_rollovers << std::endl;
        std::cout << "  Timestamp wait count: " << stats.timestamp_wait_count << std::endl;
        
        // Serialize the state
        std::string serialized_state = snowflake.serialize();
        std::cout << "Serialized state: " << serialized_state << std::endl;
        
        // Create a new instance and deserialize the state
        atom::algorithm::Snowflake<CUSTOM_EPOCH, std::mutex> restored_snowflake;
        restored_snowflake.deserialize(serialized_state);
        
        std::cout << "Restored worker ID: " << restored_snowflake.getWorkerId() << std::endl;
        std::cout << "Restored datacenter ID: " << restored_snowflake.getDatacenterId() << std::endl;
        
        // Demonstrate multi-threaded ID generation
        std::vector<std::thread> threads;
        std::vector<uint64_t> thread_ids(10);
        
        for (int i = 0; i < 10; ++i) {
            threads.emplace_back([&, i]() {
                thread_ids[i] = snowflake.nextid<1>()[0];
            });
        }
        
        for (auto& thread : threads) {
            thread.join();
        }
        
        std::cout << "Multi-threaded ID generation results:" << std::endl;
        for (size_t i = 0; i < thread_ids.size(); ++i) {
            std::cout << "  Thread " << i << " ID: " << thread_ids[i] << std::endl;
        }
        
    } catch (const atom::algorithm::SnowflakeException& e) {
        std::cerr << "Snowflake error: " << e.what() << std::endl;
        return 1;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}
```

## Best Practices

1. **Choose an appropriate epoch** that's close to your application's deployment time
2. **Use different worker and datacenter IDs** for each instance
3. **Use std::mutex for thread safety** in multi-threaded environments
4. **Handle exceptions properly** to detect clock synchronization issues
5. **Generate IDs in batches** when you need multiple IDs
6. **Monitor statistics** to detect performance issues
7. **Ensure clock synchronization** across your infrastructure

## Performance Considerations

1. The Snowflake algorithm is designed to be **high-performance**, with minimal contention
2. Use **batch generation** when possible to amortize locking overhead
3. The **thread-local cache** minimizes repeated timestamp calculations
4. **Avoid clock drift** across your infrastructure to prevent timestamp-related exceptions
